@@ JPA와 모던 자바 데이터 저장 기술 @@
 1. SQL 중심적인 개발의 문제점
 - 애플리케이션 객체지향언어 (JAVA, SCALA, ...)
 - 데이터베이스 세계의 헤게모니 관계형[RDB] - [Oracle, NySQL, ...]
 - 지금 시대는 "객체"를 "관계형 DB"에 관리
 - 하지만 위를 하기위해서 SQL문을 알아야한다.
 - 그래서 SQL중심적인 개발의 문제점
 -- 무한 반복, 지루한 코드
 CRUD
 INSERT INTO...
 UPDATE ... SET ...
 SELECT ...
 DELETE ...
 자바 객체를 SQL로...
 SQL을 자바 객체로 ...

...결과 SQL에 "의존"적인 개발을 피하기 어렵다.

 - 패러다임의 불일치 : 객체 vs 관계형 데이터베이스
 일단 두가지 사상이 다름
 관계형 데이터 베이스 - 데이터를 잘 정규화 해서 보관하는게 목표

 객체 - 속성,기능 그러니까 필드(변수)나 메서드 잘 묶어서 캡슐화 해서 사용이 목적.

 '객체 지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의
 복잡성을 제어할 수 있는 다양한 장치들을 제공한다.' - 어느 객체지향 개발자曰

객체를 영구 보관하는 다양항 저장소
Object          ->  RDB
                ->  NoSQL
                ->  File (ex 자바의 바이트코드를 시리얼라이즈(직렬화)하는걸로)
                ->  OCDB

현실적인 대안은 관계형 데이터 베이스
왜냐하면 대용량의 데이터를 처리(검색,삭제,쓰기 등등)하는데
유용한것이 현재 RDB이기 때문이다.

객체를 관계형 데이터베이스에 저장

객체 --> SQL변환 --> SQL-RDB

위에 내용을 진행하기위해 개발자 ≒ SQL매퍼

객체와 관계형 데이터베이스의 차이
☆1. 상속
☆2. 연관관계
☆3. 데이터 타입
☆4. 데이터 식별 방법


@@상속@@
ㅁ [객체의 상속 관계] : item => album, movie, book
        |
ㅁ 그나마 유사한 테이블 모델
        |
ㅁ [Table 슈퍼타입 서브타입 관계] : item => album, movie, book


객체의 내용을 SQL로 변경시
ex) 조회를 한다 가정할떄
1. 각각의 테이블에 따른 조인 SQL작성...
2. 각각의 객체 생성...
3. 상상만 해도 복장
4. 더이상의 설명은 생략한다
5. 그래서 "DB에 저장할 객체에는 상속관계 안쓴다."

자바 컬렉션에 저장하면?
list.add(album);
Album album =  list.get(albumId);

부모타입으로 조회후 다형성 활용
Item item = list.get(albumId);


@@연관관계@@
- 객체는 참조를 사용 : member.getTeam();
- 테이블은 외래키를 사용 : JOIN ON M.TEAM_ID = T.TEAM_ID;

ㅁㅁ 객체는 한방향
 참조를 받은 객체에서만 가능, 참조해준 객체는 참조를 받은 객체에게 영향을 못줌
ㅁㅁ 테이블은 양뱡항 가능.
그렇기에
--------------------------------------------------------------
ex)객체를 테이블에 맞추어 모델링함
class Member {
    String id;          //MEMBER_ID 컬럼사용
    Long teamId;        //TEAM_ID FK 컬럼 사용  //**
    String username;    //USERNAME 컬럼 사용
}
class Team{
    Long id;        //TEAM_ID PK사용
    String name;    //NAME 컬럼 사용
}
테이블에 맞춘 객체 저장
member.getId(),member.getTeamId(), member.getUserName()
INSERT INTO MEMBER(MEMBER_ID, TEAM_ID, USERNAME) VALUES(...);
team.getId(),team.getName()
INSERT INTO TEAM(TEAM_ID, NAME) VALUES(...);
--------------------------------------------------------------
--------------------------------------------------------------
ex)객체다운 모델링
class Member {
    String id;          //MEMBER_ID 컬럼사용
    Team team;          //참조로 연관관계를 맺는다. //**
    String username;    //USERNAME 컬럼 사용

    Team getTeam(){
        return  team;
    }
}
class Team{
    Long id;        //TEAM_ID PK사용
    String name;    //NAME 컬럼 사용
}
member.getId(),member.getTeam().getId(), member.getUserName()
INSERT INTO MEMBER(MEMBER_ID, TEAM_ID, USERNAME) VALUES(...);
하지만 조회할 떄 문제가 발생

SELECT M.*, T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

public Member find(String memberId) {
    //SQL 실행...
    Member merber = new Member();
    //데이터베이스에서 조회한 회원 관련 정보를 모두 입력
    Team team = new Team();
    //테이터베이스에서 조회한 팀 관련 정보를 모두 입력

    //회원과 팀 관계 설정
    member.setTeam(team);   //**
    return member;
}

객체 모델링, 자바 컬렉션에 관리
list.add(member);
Member member = list.get(memberId);
Team team = member.getTeam();
--------------------------------------------------------------
--------------------------------------------------------------
ex)객체 그래프 탐색
객체는 자유롭게 객체 그래프를 탐색할 수 있어야 한다(연관애들끼리 참조를 해야한다)
Member  -   Team            Category
  |                           |
Order   -   OrderItem   -   Item
  |
Delivery

문제는
처음 실행하는 SQL에 따라 탐색범위 결정
SELECT M.*, T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
그렇기에 밑에처럼 문제가 발생한다.
member.getTeam();   //OK
member.getOrder();   //NULL

ex)엔티티 신뢰 문제 발생
class MemberService {
    ...
    public void process() {
        Member member = memberDao.find(memberId);
        member.getTeam();   //???
        member.getOrder().getDelivery();   //???
    }
}

모든 객체를 미리 로딩할 수는 없다.
상황에 따라 동일한 회원 조회 메서드를 여러벌 생성
memberDao.getMember();  //Member
memberDao.getMemberWithTeam();  //Member, Team
memberDao.getMemberWithOrderWithDelivery(); //Member, Order, Delivery
--------------------------------------------------------------
계층형 아키텍처
진정한 의미의 계층 분할이 어렵다.
--------------------------------------------------------------
비교하기
String memberId = "100";
Member member1 = memberDao.getMember(memberId);
Member member2 = memberDao.getMember(memberId);
member1 == member2; //다르다
class MemberDao {

    public Member getMember(String memberId) {
        String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
        ...
        //JDBC API, SQL 실행
        return new Member(...);
    }
}
비교하기 - 자바 컬렉션에서 조회
String memberId = "100";
Member member1 = memberDao.getMember(memberId);
Member member2 = memberDao.getMember(memberId);
member1 == member2; //같다.

객체답게 모델링 할수록 매칭 작업만 늘어난다. ㅜㅜ
객체를 자바 컬렉션에 저장 하듯이 DB에 저장할 수는 없을까?
많은 고민을 하며 자바 진영에서 나온것이 JPA(Java Persistence API)
--------------------------------------------------------------

2. JPA 란?
- Java Persistence API
- 자바 진여의 ORM 기술 표준
--------------------------------------------------------------
ORM 이란?
- Object-relational mapping(객체 관계 매핑)
- 객체는 객체대로 설계
- 관계형 데이터베이스는 관계형 데이터베이스대로 설계
- ORM 프레임워크가 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재

--------------------------------------------------------------
@@ JPA는 애플리케이션과 JDBC 사이에서 동작
                                  - SQL->
JAVA애플리케이션 - JPA - JDBC API -           DB
                                  <-결과 -

@@ JPA동작 - 저장
-------------------------------------------------------------
|            [Entity Objecct]  |-------------------------- |
|    [MemberDAO] -- [PERSIST] -->   JPA                   | | INSERT
|                              | - Entity분석        ------| | SQL
|                              | - INSERT SQL생성    -JDBC |-|-----------> DB
|                              | - JDBC API 사용     -API  | |
|                              | - 패러다임 불일치 해결----- | |
|                              |--------------------------| |
------------------------------JVM---------------------------|



